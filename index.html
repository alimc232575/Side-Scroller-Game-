<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Side-Scroller Action Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1b26;
            color: #f0f0f0;
            overflow: hidden; /* Prevent scrollbars */
            margin: 0;
            padding: 0;
        }
        canvas {
            background-color: #2c2d3c;
            display: block;
            border-bottom: 5px solid #4a4b5c;
        }
        .game-wrapper {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 1000px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to canvas if needed */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }
        .top-ui {
            display: flex;
            justify-content: space-between;
            font-size: 1.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }
        #powerup-status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 1.2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            color: #2ecc71;
        }
        .start-screen, .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 27, 38, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }
        .btn {
            background-color: #8e44ad;
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.2rem;
            border: none;
            box-shadow: 0 5px #6c3483;
            transition: all 0.1s ease-in-out;
            margin-top: 20px;
            pointer-events: all;
        }
        .btn:active {
            transform: translateY(3px);
            box-shadow: 0 2px #6c3483;
        }
        .difficulty-selector {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            pointer-events: all;
        }
        .difficulty-btn {
             background-color: #4a4b5c;
             padding: 10px 20px;
             border-radius: 8px;
             cursor: pointer;
        }
        .difficulty-btn.selected {
             background-color: #e74c3c;
             box-shadow: 0 0 15px #e74c3c;
        }
        .instructions {
             margin-top: 20px;
             line-height: 1.8;
             font-size: 0.9rem;
        }
    </style>
</head>
<body>

<div class="game-wrapper">
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui-container">
            <div class="top-ui">
                <div id="score">Score: 0</div>
                <div id="lives">Lives: 3</div>
            </div>
            <div id="powerup-status"></div>
        </div>

        <div id="start-screen" class="start-screen">
            <h1 class="text-4xl md:text-5xl mb-4">Pixel Rusher</h1>
            <p class="mb-4">Select your starting difficulty:</p>
            <div class="difficulty-selector">
                <div class="difficulty-btn" data-difficulty="easy">Easy</div>
                <div class="difficulty-btn" data-difficulty="medium">Medium</div>
                <div class="difficulty-btn" data-difficulty="hard">Hard</div>
            </div>
            <button id="start-btn" class="btn">Start Game</button>
            <div class="instructions">
                <p>Arrow Keys: Move & Jump</p>
                <p>Down Arrow: Duck / Slam (in air)</p>
                <p>Spacebar / Tap Screen: Shoot</p>
                <p>Hold Up Arrow in air to Hover/Jetpack!</p>
            </div>
        </div>

        <div id="game-over-screen" class="game-over-screen" style="display: none;">
            <h1 class="text-4xl md:text-5xl mb-4">Game Over</h1>
            <p id="final-score" class="text-2xl mb-6"></p>
            <button id="restart-btn" class="btn">Play Again</button>
        </div>
    </div>
</div>

<script>
// --- Game Setup ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const gameContainer = document.getElementById('game-container');

// UI Elements
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const powerupStatusEl = document.getElementById('powerup-status');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const startBtn = document.getElementById('start-btn');
const restartBtn = document.getElementById('restart-btn');
const finalScoreEl = document.getElementById('final-score');
const difficultySelector = document.querySelector('.difficulty-selector');

// Game state
let score, lives, gameSpeed, obstacleFrequency, difficulty;
let player, obstacles, bullets, collectibles, particles;
let keys = {};
let gameState = 'start';
let animationFrameId;
let frameCount = 0;

// --- More Robust Music Engine ---
let music;
function setupMusic() {
    if (music && music.loop) {
        return; // Already initialized
    }
    if (music) {
        if (music.loop) music.loop.dispose();
        Object.values(music.synths).forEach(synth => synth.dispose());
    }
    Tone.Transport.cancel();

    const synths = {
        lead: new Tone.FMSynth({ harmonicity: 1.5, modulationIndex: 10, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 }, modulation: { type: "sawtooth" } }).toDestination(),
        bass: new Tone.MonoSynth({ oscillator: { type: 'fmsquare', modulationType: 'sawtooth', modulationIndex: 0.2 }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.4, release: 0.2 } }).toDestination(),
        kick: new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: 'exponential' } }).toDestination(),
        snare: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).toDestination(),
        nag: new Tone.AMSynth({ harmonicity: 1.2, oscillator: { type: "sine" }, envelope: { attack: 0.02, decay: 0.3, sustain: 0.1, release: 0.5 }, modulation: { type: "sawtooth" }, modulationEnvelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.01 } }).toDestination(),
        penis: new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 4, envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 } }).toDestination(),
        boobs: new Tone.FMSynth({ harmonicity: 0.5, modulationIndex: 3, envelope: { attack: 0.05, decay: 0.2, sustain: 0, release: 0.1 }, modulation: { type: "sine" }, modulationEnvelope: { attack: 0.05, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(),
        love: new Tone.MetalSynth({ frequency: 400, harmonicity: 8, modulationIndex: 20, envelope: { attack: 0.01, decay: 0.4, release: 0.2 }, resonance: 4000 }).toDestination(),
        // --- NEW: Crying Baby Sound ---
        babyWah: new Tone.FMSynth({
            harmonicity: 3.1,
            modulationIndex: 15,
            detune: 0,
            oscillator: { type: "sine" },
            envelope: { attack: 0.02, decay: 0.2, sustain: 0.5, release: 0.8 },
            modulation: { type: "square" },
            modulationEnvelope: { attack: 0.05, decay: 0.1, sustain: 0.8, release: 0.5 }
        }).toDestination()
    };
    synths.bass.volume.value = -10;
    synths.snare.volume.value = -6;
    synths.nag.volume.value = -8;
    synths.penis.volume.value = -12;
    synths.boobs.volume.value = -8;
    synths.love.volume.value = -15;
    synths.babyWah.volume.value = -3; // It should be loud!

    const patterns = {
        intro:  { lead: [],                            bass: ['C2'], kick: true, snare: false },
        verse:  { lead: ['C4', null, 'E4', 'G4', null, 'E4', 'C4', null], bass: ['C2', 'G1', 'A1', 'F1'], kick: true, snare: true },
        chorus: { lead: ['C5', 'G4', 'A4', 'G4', 'C5', 'A4', 'G4', 'E4'], bass: ['F1', 'C1', 'G1', 'C1'], kick: true, snare: true },
        bridge: { lead: ['D5', 'E5', 'F#5', 'E5'],                    bass: ['D2', 'A1'], kick: false, snare: false },
        outro:  { lead: ['C4'],                            bass: ['C2'], kick: false, snare: false }
    };

    let beat = 0;
    let songPosition = 0;
    const songStructure = ['intro', 'intro', 'verse', 'verse', 'chorus', 'chorus', 'verse', 'bridge', 'chorus', 'chorus', 'outro', 'outro'];

    const musicLoop = new Tone.Loop(time => {
        Tone.Draw.schedule(() => {
            const currentPart = patterns[songStructure[songPosition]];
            
            if (currentPart.lead.length > 0) {
                const note = currentPart.lead[beat % currentPart.lead.length];
                if (note) synths.lead.triggerAttackRelease(note, '16n', time);
            }
            if (currentPart.bass.length > 0 && beat % 4 === 0) {
                const note = currentPart.bass[Math.floor(beat / 4) % currentPart.bass.length];
                if (note) synths.bass.triggerAttackRelease(note, '4n', time);
            }
            if (currentPart.kick && beat % 4 === 0) {
                synths.kick.triggerAttackRelease('C2', '8n', time);
            }
            if (currentPart.snare && beat % 8 === 4) {
                synths.snare.triggerAttackRelease('16n', time);
            }

            beat++;
            if (beat >= 16) {
                beat = 0;
                songPosition = (songPosition + 1) % songStructure.length;
            }
        }, time);
    }, '16n');

    music = { loop: musicLoop, synths };
}


// --- Sizing and Responsiveness ---
function resizeCanvas() {
    canvas.width = gameContainer.clientWidth;
    canvas.height = gameContainer.clientWidth * 0.6;
    if (gameState !== 'playing') drawInitialState();
}

// --- Player Class ---
class Player {
    constructor() {
        this.x = 50; this.y = canvas.height - 60;
        this.width = 40; this.height = 50;
        this.dx = 0; this.dy = 0; this.jumpPower = 18; this.gravity = 0.8;
        this.moveSpeed = 5;
        this.friction = 0.85;

        this.isJumping = false; this.isDucking = false; this.duckHeight = 30;
        this.rotation = 0;
        this.jumpsRemaining = 2; this.maxJumps = 2;
        this.powerupType = 'normal'; this.powerupTimer = 0;
        this.isSlamming = false;
        this.shootCooldown = 0;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
        ctx.rotate(this.rotation);
        ctx.fillStyle = '#3498db';
        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
        ctx.restore();
    }

    update() {
        let currentGravity = this.gravity;
        if (this.isJumping && keys['ArrowUp']) {
            if (this.powerupType === 'hover') currentGravity = 0.1;
            if (this.powerupType === 'jetpack') this.dy -= 1.2;
        }
        
        if (this.shootCooldown > 0) this.shootCooldown--;

        this.x += this.dx;
        this.y += this.dy;
        this.dx *= this.friction;
        this.dy += currentGravity;

        if (this.x < 0) { this.x = 0; this.dx = 0; }
        if (this.x + this.width > canvas.width) { this.x = canvas.width - this.width; this.dx = 0; }
        if (this.y < 0) { this.y = 0; if (this.dy < 0) this.dy = 0; }
        if (this.y + this.height >= canvas.height) {
            this.land();
        }

        if (this.isJumping) this.rotation += 0.2;
        
        if (this.powerupTimer > 0) {
            this.powerupTimer--;
            powerupStatusEl.textContent = `${this.powerupType.replace('_', ' ').toUpperCase()}! ${Math.ceil(this.powerupTimer / 60)}s`;
            if (this.powerupTimer <= 0) this.resetPowerup();
        } else {
            const weaponTypes = ['normal', 'mortar', 'multi', 'spiral', 'goose', 'love', 'random', 'penis', 'boobs', 'grandma', 'crying_baby'];
            if (weaponTypes.includes(this.powerupType)) {
                 powerupStatusEl.textContent = `${this.powerupType.toUpperCase()}`;
            }
        }
        this.draw();
    }

    land() {
        this.y = canvas.height - this.height;
        if (this.isSlamming) { obstacles.forEach(o => o.takeDamage(1000)); this.isSlamming = false; }
        this.isJumping = false;
        this.dy = 0;
        this.jumpsRemaining = this.maxJumps;
        this.rotation = 0;
    }

    jump() {
        if (this.jumpsRemaining > 0) {
            this.isJumping = true;
            this.dy = -this.jumpPower;
            this.jumpsRemaining--;
        }
    }
    
    duck(shouldDuck) { if (!this.isJumping) this.isDucking = shouldDuck; }

    slam() {
        if (this.isJumping && this.powerupType === 'slam') {
            this.dy = 35;
            this.powerupTimer = 0;
            this.resetPowerup();
            this.isSlamming = true;
        }
    }

    equipPowerup(type, category) {
        this.resetPowerup(); this.powerupType = type;
        if (category === 'jump') {
            this.powerupTimer = (type === 'slam') ? 1200 : 600;
            if (type === 'triple_jump') this.maxJumps = 3;
        }
        this.jumpsRemaining = this.maxJumps;
    }
    
    resetPowerup() {
        this.powerupType = 'normal'; this.maxJumps = 2;
        this.jumpsRemaining = Math.min(this.jumpsRemaining, 2);
        powerupStatusEl.textContent = '';
    }
}

// --- Entity Classes ---
const obstacleTypes = { white: { health: 1, color: '#ecf0f1' }, yellow: { health: 3, color: '#f1c40f' }, red: { health: 10, color: '#e74c3c' } };
class Obstacle {
    constructor(x, y, w, h, strength) {
        this.x = x; this.y = y; this.width = w; this.height = h;
        this.strength = strength; this.health = obstacleTypes[strength].health; this.color = obstacleTypes[strength].color;
        this.naggingGrandmas = 0;
        this.isMelting = false; 
        this.animOffset = Math.random() * 100; // --- NEW: For Wiggle Animation
    }
    draw() {
        ctx.save();
        // --- NEW: Wiggle Animation ---
        const wiggleAmount = 5;
        const wiggleSpeed = 0.05;
        const wiggleOffset = Math.sin((frameCount + this.animOffset) * wiggleSpeed) * wiggleAmount;
        ctx.translate(0, wiggleOffset);

        if (this.naggingGrandmas >= 3 && frameCount % 10 < 5) {
            ctx.fillStyle = '#ffffff';
        } else {
            ctx.fillStyle = this.color;
        }
        if (this.isMelting) {
             ctx.globalAlpha = this.health / obstacleTypes[this.strength].health;
        }
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.restore();
    }
    update() {
        if (this.naggingGrandmas >= 3) {
            this.health = 0;
            for(let i=0; i<10; i++) particles.push(new Particle(this.x + this.width/2, this.y + this.height/2, 'boredom'));
        }
        if (this.isMelting) {
            this.health -= 0.1;
            this.y += 0.5;
        }
        this.x -= gameSpeed;
        this.draw();
    }
    takeDamage(amount) { this.health -= amount; }
}

class Bullet {
    constructor(x, y, type = 'normal', angle = 0) {
        this.x = x; this.y = y; this.type = type;
        this.dx = 10; this.dy = 0; this.damage = 1; this.gravity = 0.3; this.angle = angle;
        this.target = null; this.stuckTo = null; this.life = 180;
        this.width = 15; this.height = 5;
        this.animFrame = 0;
        this.state = 'flying';
        
        if (type === 'mortar') { this.width = 15; this.height = 15; this.dy = -12; }
        else if (type === 'multi' || type === 'random') { this.width = 8; this.height = 8; this.dx = (Math.random() - 0.5) * 12; this.dy = (Math.random() - 0.5) * 12; }
        else if (type === 'spiral') { this.width = 10; this.height = 10; this.dx = Math.cos(frameCount * 0.1) * 8; this.dy = Math.sin(frameCount * 0.1) * 8; }
        else if (type === 'goose') { this.width = 12; this.height = 6; this.dy = Math.sin(this.angle) * 8; this.dx = Math.cos(this.angle) * 8;}
        else if (type === 'love') { this.width = 10; this.height = 10; }
        else if (type === 'penis') {
            this.width = 8; this.height = 20; this.state = 'charging'; this.dx = 0; this.dy = -8; this.life = 30;
            this.liquidType = Math.random() < 0.5 ? 'white' : 'yellow';
        }
        else if (type === 'boobs') { this.state = 'growing'; this.currentSize = 5; this.maxSize = 40; this.growSpeed = 2; this.width = this.currentSize * 2; this.height = this.currentSize; this.dx = 0; }
        else if (type === 'grandma') { this.width = 15; this.height = 15; this.state = 'seeking_orbit'; this.seek(); }
        // --- NEW: Crying Baby Logic ---
        else if (type === 'crying_baby') {
            this.width = 20; this.height = 20;
            this.state = 'seeking';
            this.damage = 5; // Shockwave damage
            this.seek();
        }
    }
    draw() {
        ctx.fillStyle = '#ffc0cb';
        switch(this.type) {
            case 'love': ctx.font = "15px 'Press Start 2P'"; ctx.fillText("❤", this.x, this.y); break;
            case 'penis':
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                ctx.beginPath(); ctx.arc(0, -this.height/2, this.width, 0, Math.PI); ctx.fill();
                ctx.restore();
                break;
            case 'boobs':
                ctx.beginPath(); ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(this.x + this.currentSize * 1.5, this.y, this.currentSize, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#d48a96';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.currentSize * 0.2, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(this.x + this.currentSize * 1.5, this.y, this.currentSize * 0.2, 0, Math.PI * 2); ctx.fill();
                break;
            case 'grandma':
                const wobbleX = Math.sin(this.animFrame * 0.5) * 2; const wobbleY = Math.cos(this.animFrame * 0.3) * 2;
                ctx.save(); ctx.translate(this.x + wobbleX, this.y + wobbleY);
                ctx.fillStyle = '#f0d9c4'; ctx.fillRect(0, 0, this.width, this.height);
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.width/2, 0, this.width/2, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#000'; ctx.fillRect(3, 5, 2, 2); ctx.fillRect(10, 5, 2, 2);
                if (this.animFrame % 20 < 10) { ctx.fillRect(5, 12, 5, 2); particles.push(new Particle(this.x, this.y, 'nag')); }
                ctx.restore();
                break;
            // --- NEW: Crying Baby Drawing ---
            case 'crying_baby':
                ctx.fillStyle = '#f0d9c4'; // Skin tone
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000'; // Eyes
                ctx.fillRect(this.x - 5, this.y - 2, 2, 2);
                ctx.fillRect(this.x + 3, this.y - 2, 2, 2);
                ctx.strokeStyle = '#000'; // Crying mouth
                ctx.beginPath();
                ctx.arc(this.x, this.y + 5, 4, 0, Math.PI);
                ctx.stroke();
                // Add tear particles
                if (frameCount % 5 === 0) {
                    particles.push(new Particle(this.x, this.y + 10, 'tear'));
                }
                break;
            default:
                ctx.fillStyle = '#9b59b6'; ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    }
    update() {
        this.animFrame++;
        if (this.stuckTo) {
            this.x += this.stuckTo.x - this.stuckTo.prevX; this.y += this.stuckTo.y - this.stuckTo.prevY;
            this.stuckTo.prevX = this.stuckTo.x; this.stuckTo.prevY = this.stuckTo.y;
            this.life--;
            if (this.life <= 0) {
                for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, 'love'));
                this.stuckTo.takeDamage(5); this.remove = true;
            }
        } else {
            switch(this.state) {
                case 'growing':
                    this.currentSize += this.growSpeed;
                    if (this.currentSize >= this.maxSize) { this.state = 'flying'; this.dx = 12; }
                    break;
                case 'charging':
                    this.life--; this.y += this.dy; this.dy *= 0.9;
                    if(this.life <= 0) { this.state = 'seeking'; this.seek(); }
                    break;
                case 'seeking':
                case 'seeking_orbit':
                    this.seek(); this.x += this.dx; this.y += this.dy;
                    if (this.type === 'grandma' && this.target) {
                        const dist = Math.hypot(this.x - this.target.x, this.y - this.y);
                        if (dist < 50) { this.state = 'orbiting'; this.target.naggingGrandmas++; }
                    }
                    break;
                case 'orbiting':
                    this.x += (this.target.x - 40 - this.x) * 0.1; this.y += (this.target.y - this.y) * 0.1;
                    if (!this.target || this.target.health <= 0) { this.remove = true; }
                    break;
                case 'flying':
                default:
                    if (this.type === 'mortar') this.dy += this.gravity;
                    this.x += this.dx; this.y += this.dy;
            }
        }
        this.draw();
    }
    seek() {
        if (!this.target || !obstacles.includes(this.target) || this.target.health <= 0) {
            let closest = null; let closestDist = Infinity;
            obstacles.forEach(o => {
                const dist = Math.hypot(this.x - o.x, this.y - o.y);
                if (dist < closestDist) { closest = o; closestDist = dist; }
            });
            this.target = closest;
        }
        if (this.target) {
            let speed = 8;
            if (this.type === 'penis') speed = 15;
            if (this.type === 'crying_baby') speed = 3;

            const targetAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
            this.dx = Math.cos(targetAngle) * speed; this.dy = Math.sin(targetAngle) * speed;
            this.angle = targetAngle;
        } else if (this.type === 'penis' || this.type === 'grandma' || this.type === 'crying_baby') {
            this.remove = true;
        }
    }
}

class Collectible {
    constructor(x, y, powerupType, category) {
        this.x = x; this.y = y; this.width = 30; this.height = 30;
        this.powerupType = powerupType; this.category = category;
        this.color = (category === 'weapon') ? '#e67e22' : '#2ecc71';
    }
    draw() {
        ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.fillStyle = '#ffffff'; ctx.font = '20px "Press Start 2P"';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        const letter = this.category === 'weapon' ? 'W' : 'J';
        ctx.fillText(letter, this.x + this.width / 2, this.y + this.height / 2 + 2);
    }
    update() { this.x -= gameSpeed; this.draw(); }
}

class Particle {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type; this.life = 60;
        this.dx = (Math.random() - 0.5) * 6;
        this.dy = (Math.random() - 0.5) * 6;
        this.gravity = 0.1;
        this.isStuck = false;
    }
    draw() {
        ctx.globalAlpha = this.life / 60;
        if (this.type === 'love') {
            ctx.fillStyle = '#ff69b4'; ctx.font = "15px 'Press Start 2P'"; ctx.fillText("❤", this.x, this.y);
        // --- NEW: Tear & Shockwave Particles ---
        } else if (this.type === 'tear') {
            ctx.fillStyle = '#aed6f1';
            ctx.beginPath();
            ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
            ctx.fill();
        } else if (this.type === 'shockwave') {
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, (60 - this.life) / 4, 0, Math.PI * 2);
            ctx.stroke();
        } else if (this.type === 'milk' || this.type === 'sticky_goo') {
            ctx.fillStyle = this.type === 'milk' ? '#ffffff' : '#f5f5f5';
            ctx.fillRect(this.x, this.y, 4, 4);
        } else if (this.type === 'nag') {
            ctx.fillStyle = '#aaaaaa'; ctx.font = "8px 'Press Start 2P'"; ctx.fillText("...", this.x, this.y);
        } else if (this.type === 'boredom') {
            ctx.fillStyle = '#ffffff'; ctx.font = "15px 'Press Start 2P'"; ctx.fillText("POOF!", this.x, this.y);
        }
        ctx.globalAlpha = 1.0;
    }
    update() {
        this.life--;
        if (this.type === 'sticky_goo') {
            if (this.isStuck) {
                this.dy = 0.5; // Ooze down
            } else {
                this.dy += this.gravity;
                if (this.x <= 0 || this.x >= canvas.width || this.y <= 0) {
                    this.isStuck = true;
                    this.dx = 0;
                }
            }
        } else if (this.type === 'milk' || this.type === 'tear') {
            this.dy += this.gravity;
        }
        this.x += this.dx; this.y += this.dy;
        this.draw();
    }
}


// --- Game Initialization ---
function init() {
    if (Tone.context.state !== 'running') { Tone.start(); }
    setupMusic();
    Tone.Transport.start('+0.1');

    score = 0; lives = 3; frameCount = 0;
    const difficultySettings = { 
        easy:   { speed: 1.2, freq: 68 },
        medium: { speed: 1.6, freq: 57 },
        hard:   { speed: 2.0, freq: 45 }
    };
    const setting = difficultySettings[difficulty];
    gameSpeed = setting.speed; obstacleFrequency = setting.freq;

    player = new Player();
    obstacles = []; bullets = []; collectibles = []; particles = [];
    
    scoreEl.textContent = `Score: ${score}`; livesEl.textContent = `Lives: ${lives}`;
    powerupStatusEl.textContent = '';
    
    startScreen.style.display = 'none'; gameOverScreen.style.display = 'none';
    gameState = 'playing';
    gameLoop();
}

// --- Game Loop ---
function gameLoop() {
    if (gameState !== 'playing') return;
    animationFrameId = requestAnimationFrame(gameLoop);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    frameCount++;
    
    if (keys['ArrowLeft']) { player.dx -= player.moveSpeed / 5; }
    if (keys['ArrowRight']) { player.dx += player.moveSpeed / 5; }

    player.update();
    handleShooting();

    if (frameCount % 450 === 0) spawnCollectible();
    collectibles.forEach((c, i) => {
        c.update();
        if (checkCollision(player, c)) { player.equipPowerup(c.powerupType, c.category); collectibles.splice(i, 1); }
        if (c.x + c.width < 0) collectibles.splice(i, 1);
    });

    if (frameCount % obstacleFrequency === 0) spawnObstacle();
    obstacles.forEach((o, i) => {
        o.prevX = o.x; o.prevY = o.y;
        o.update();
        if (o.health <= 0) {
            obstacles.splice(i, 1);
            score += 20; scoreEl.textContent = `Score: ${score}`;
        } else if (checkCollision(player, o)) {
            obstacles.splice(i, 1); lives--; livesEl.textContent = `Lives: ${lives}`;
            if (lives <= 0) endGame();
        }
        if (o.x + o.width < 0) { obstacles.splice(i, 1); score += 5; scoreEl.textContent = `Score: ${score}`; }
    });

    bullets.forEach((b, bIndex) => {
        b.update();
        if (b.remove || b.x > canvas.width || b.x < 0 || b.y > canvas.height || b.y < 0) {
            if (b.type === 'grandma' && b.target) b.target.naggingGrandmas--;
            bullets.splice(bIndex, 1);
        }
        obstacles.forEach((o, oIndex) => {
            if (checkCollision(b, o)) {
                if (!bullets.includes(b)) return;
                
                // --- NEW: Crying Baby Collision ---
                if (b.type === 'crying_baby') {
                    if (music && music.synths.babyWah) music.synths.babyWah.triggerAttackRelease('A5', '0.5s');
                    
                    for (let i = 0; i < 20; i++) {
                         particles.push(new Particle(b.x, b.y, 'shockwave'));
                    }

                    obstacles.forEach(otherObstacle => {
                        const dist = Math.hypot(b.x - otherObstacle.x, b.y - otherObstacle.y);
                        if (dist < 100) { // Shockwave radius
                            otherObstacle.takeDamage(b.damage);
                        }
                    });
                    bullets.splice(bIndex, 1);
                }
                else if (b.type === 'boobs') {
                    for (let i = 0; i < 30; i++) particles.push(new Particle(b.x, b.y, 'milk'));
                }
                
                else if (b.type === 'love' && !b.stuckTo) { b.stuckTo = o; } 
                else if (b.type === 'penis') {
                    if (b.liquidType === 'yellow') {
                        o.isMelting = true;
                    } else {
                        o.takeDamage(1000); // Instant kill
                        for (let i = 0; i < 20; i++) {
                            particles.push(new Particle(b.x, b.y, 'sticky_goo'));
                        }
                    }
                    bullets.splice(bIndex, 1);
                }
                else if (b.type !== 'love' && b.type !== 'grandma') {
                    bullets.splice(bIndex, 1);
                    o.takeDamage(b.damage);
                }
            }
        });
    });

    particles.forEach((p, i) => { p.update(); if (p.life <= 0) particles.splice(i, 1); });
    
    if(frameCount % 500 === 0 && frameCount > 0) {
        gameSpeed += 0.1;
        if (obstacleFrequency > 25) {
            obstacleFrequency -= 2;
        }
    }
}

// --- Helper Functions ---
function spawnObstacle() {
    const rand = Math.random();
    const strength = rand < 0.6 ? 'white' : rand < 0.9 ? 'yellow' : 'red';
    const h = Math.random() * 50 + 30, w = Math.random() * 20 + 20;
    let x = canvas.width;
    let y = Math.random() * (canvas.height - h);
    obstacles.push(new Obstacle(x, y, w, h, strength));
}

function spawnCollectible() {
    const category = Math.random() < 0.7 ? 'weapon' : 'jump';
    // --- NEW: Added crying_baby to powerups ---
    const weaponTypes = ['mortar', 'multi', 'spiral', 'goose', 'love', 'random', 'penis', 'boobs', 'grandma', 'crying_baby'];
    const jumpTypes = ['triple_jump', 'hover', 'jetpack', 'slam'];
    const type = (category === 'weapon') ? weaponTypes[Math.floor(Math.random() * weaponTypes.length)] : jumpTypes[Math.floor(Math.random() * jumpTypes.length)];
    const y = Math.random() * (canvas.height - 100) + 50;
    const x = canvas.width;
    collectibles.push(new Collectible(x, y, type, category));
}

function checkCollision(rect1, rect2) {
    const r1 = (rect1 === player) ? { x: player.x, y: player.y, width: player.width, height: player.height } : rect1;
    return (r1.x < rect2.x + rect2.width && r1.x + r1.width > rect2.x && r1.y < rect2.y + rect2.height && r1.y + r1.height > rect2.y);
}

function handleShooting() {
    if (player.powerupType === 'random' && frameCount % 3 === 0) {
        bullets.push(new Bullet(Math.random() * canvas.width, Math.random() * canvas.height, 'random'));
    }
    if (keys['Space']) {
        const bX = player.x + player.width / 2, bY = player.y + player.height / 2;
        if (player.powerupType === 'normal' && frameCount % 6 === 0) bullets.push(new Bullet(bX, bY, 'normal'));
        if (player.powerupType === 'mortar' && frameCount % 20 === 0) bullets.push(new Bullet(bX, bY, 'mortar'));
        if (player.powerupType === 'multi' && frameCount % 2 === 0) bullets.push(new Bullet(bX, bY, 'multi'));
        if (player.powerupType === 'spiral' && frameCount % 2 === 0) bullets.push(new Bullet(bX, bY, 'spiral'));
        if (player.powerupType === 'goose' && frameCount % 10 === 0) {
            bullets.push(new Bullet(bX, bY, 'goose', -0.3)); bullets.push(new Bullet(bX, bY, 'goose', 0.3));
        }
        if (player.powerupType === 'love' && frameCount % 8 === 0) {
            bullets.push(new Bullet(bX, bY, 'love'));
            if (music && music.synths.love) music.synths.love.triggerAttackRelease('C6', '0.5s');
        }
        if (player.powerupType === 'penis' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'penis'));
            player.shootCooldown = 20;
            if (music && music.synths.penis) music.synths.penis.triggerAttackRelease('C3', '8n');
        }
        if (player.powerupType === 'boobs' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'boobs'));
            player.shootCooldown = 30;
            if (music && music.synths.boobs) music.synths.boobs.triggerAttackRelease('G2', '16n');
        }
        if (player.powerupType === 'grandma' && frameCount % 8 === 0) {
            bullets.push(new Bullet(bX, bY, 'grandma'));
            if (music && music.synths.nag) music.synths.nag.triggerAttackRelease('G#5', '0.3s');
        }
        // --- NEW: Crying Baby Firing ---
        if (player.powerupType === 'crying_baby' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'crying_baby'));
            player.shootCooldown = 45; // Slower fire rate
        }
    }
}

function endGame() {
    gameState = 'over';
    Tone.Transport.stop();
    if (music && music.loop) {
        music.loop.dispose();
        Object.values(music.synths).forEach(synth => synth.dispose());
        music = null;
    }
    cancelAnimationFrame(animationFrameId);
    gameOverScreen.style.display = 'flex';
    finalScoreEl.textContent = `Final Score: ${score}`;
}

// --- Event Listeners ---
window.addEventListener('keydown', (e) => {
    if (e.repeat) return; keys[e.code] = true;
    if (gameState !== 'playing') return;
    if (e.code === 'ArrowUp') player.jump();
    if (e.code === 'ArrowDown') { if (player.isJumping) player.slam(); else player.duck(true); }
});
window.addEventListener('keyup', (e) => { keys[e.code] = false; if (e.code === 'ArrowDown') player.duck(false); });

// Touch Controls
let touchStartY = 0;
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); touchStartY = e.touches[0].clientY;
    keys['Space'] = true; keys['ArrowUp'] = true; 
}, { passive: false });
canvas.addEventListener('touchmove', (e) => {
    e.preventDefault(); let touchEndY = e.touches[0].clientY;
    if (touchStartY - touchEndY > 40) { player.jump(); touchStartY = touchEndY; } 
    else if (touchEndY - touchStartY > 40) { if (player.isJumping) player.slam(); else player.duck(true); }
}, { passive: false });
canvas.addEventListener('touchend', (e) => {
    e.preventDefault(); keys['Space'] = false; keys['ArrowUp'] = false; player.duck(false);
}, { passive: false });

// UI Buttons
startBtn.addEventListener('click', () => { if (difficulty) init(); });
restartBtn.addEventListener('click', () => {
    startScreen.style.display = 'flex'; gameOverScreen.style.display = 'none';
    gameState = 'start'; drawInitialState();
});
difficultySelector.addEventListener('click', (e) => {
    if (e.target.classList.contains('difficulty-btn')) {
        document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('selected'));
        e.target.classList.add('selected');
        difficulty = e.target.dataset.difficulty;
    }
});

// Initial Setup
window.addEventListener('resize', resizeCanvas);
function drawInitialState() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const tempPlayer = new Player();
    tempPlayer.y = canvas.height - 60; tempPlayer.draw();
    ctx.fillStyle = '#4a4b5c';
    ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
}

document.querySelector('[data-difficulty="medium"]').classList.add('selected');
difficulty = 'medium';
resizeCanvas();

</script>
</body>
</html>
