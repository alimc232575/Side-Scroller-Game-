<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Side-Scroller Action Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1b26;
            color: #f0f0f0;
            overflow: hidden; /* Prevent scrollbars */
            margin: 0;
            padding: 0;
        }
        canvas {
            background-color: #2c2d3c;
            display: block;
            border-bottom: 5px solid #4a4b5c;
        }
        .game-wrapper {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 1000px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to canvas if needed */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }
        .top-ui {
            display: flex;
            justify-content: space-between;
            font-size: 1.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }
        #powerup-status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 1.2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            color: #2ecc71;
        }
        /* NEW: Health Bar Styling */
        #health-bar-container {
            width: 200px; /* Fixed width for the bar */
            height: 25px;
            background-color: #555;
            border: 2px solid #fff;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 10px; /* Space between health and score */
            pointer-events: none;
            position: relative; /* For text overlay */
        }
        #health-bar {
            height: 100%;
            background-color: #e74c3c; /* Red color for health */
            width: 100%; /* Will be controlled by JS */
            transition: width 0.2s ease-out; /* Smooth transition for health changes */
        }
        #health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            white-space: nowrap;
        }
        .start-screen, .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(26, 27, 38, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }
        .btn {
            background-color: #8e44ad;
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.2rem;
            border: none;
            box-shadow: 0 5px #6c3483;
            transition: all 0.1s ease-in-out;
            margin-top: 20px;
            pointer-events: all;
        }
        .btn:active {
            transform: translateY(3px);
            box-shadow: 0 2px #6c3483;
        }
        .difficulty-selector {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            pointer-events: all;
        }
        .difficulty-btn {
             background-color: #4a4b5c;
             padding: 10px 20px;
             border-radius: 8px;
             cursor: pointer;
        }
        .difficulty-btn.selected {
             background-color: #e74c3c;
             box-shadow: 0 0 15px #e74c3c;
        }
        .instructions {
             margin-top: 20px;
             line-height: 1.8;
             font-size: 0.9rem;
        }
    </style>
</head>
<body>

<div class="game-wrapper">
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui-container">
            <div class="top-ui">
                <div id="health-bar-container">
                    <div id="health-bar"></div>
                    <div id="health-text"></div>
                </div>
                <div id="score">Score: 0</div>
                <div id="lives">Lives: 3</div>
            </div>
            <div id="powerup-status"></div>
        </div>

        <div id="start-screen" class="start-screen">
            <h1 class="text-4xl md:text-5xl mb-4">Pixel Rusher</h1>
            <p class="mb-4">Select your starting difficulty:</p>
            <div class="difficulty-selector">
                <div class="difficulty-btn" data-difficulty="easy">Easy</div>
                <div class="difficulty-btn" data-difficulty="medium">Medium</div>
                <div class="difficulty-btn" data-difficulty="hard">Hard</div>
            </div>
            <button id="start-btn" class="btn">Start Game</button>
            <div class="instructions">
                <p>Arrow Keys: Move & Jump</p>
                <p>Down Arrow: Duck / Slam (in air)</p>
                <p>Spacebar / Tap Screen: Shoot</p>
                <p>Hold Up Arrow in air to Hover/Jetpack!</p>
            </div>
        </div>

        <div id="game-over-screen" class="game-over-screen" style="display: none;">
            <h1 class="text-4xl md:text-5xl mb-4">Game Over</h1>
            <p id="final-score" class="text-2xl mb-6"></p>
            <button id="restart-btn" class="btn">Play Again</button>
        </div>
    </div>
</div>

<script>
// --- Game Setup ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const gameContainer = document.getElementById('game-container');

// UI Elements
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const powerupStatusEl = document.getElementById('powerup-status');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const startBtn = document.getElementById('start-btn');
const restartBtn = document.getElementById('restart-btn');
const finalScoreEl = document.getElementById('final-score');
const difficultySelector = document.querySelector('.difficulty-selector');
const healthBar = document.getElementById('health-bar');
const healthText = document.getElementById('health-text');


// Game state
let score, lives, gameSpeed, obstacleFrequency, difficulty;
let player, obstacles, bullets, collectibles, particles;
let keys = {};
let gameState = 'start';
let animationFrameId;
let frameCount = 0;
let nextExtraLifeScore = 1000;
let blocksPassed = 0;
let nextBossBlockCount = 1000;
let bossActive = false;

// --- Global variable for Tone.js cooldowns ---
let lastBabyWahTime = 0;
const babyWahCooldown = 0.6;
let lastMogleyFaceTime = 0;
const mogleyFaceCooldown = 5;
let lastFootKickSoundTime = 0;
const footKickSoundCooldown = 0.1;


// --- More Robust Music Engine ---
let music;
function setupMusic() {
    if (music && music.loop) {
        return; // Already initialized
    }
    if (music) {
        if (music.loop) music.loop.dispose();
        Object.values(music.synths).forEach(synth => synth.dispose());
    }
    Tone.Transport.cancel();

    const synths = {
        lead: new Tone.FMSynth({ harmonicity: 1.5, modulationIndex: 10, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 }, modulation: { type: "sawtooth" } }).toDestination(),
        bass: new Tone.MonoSynth({ oscillator: { type: 'fmsquare', modulationType: 'sawtooth', modulationIndex: 0.2 }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.4, release: 0.2 } }).toDestination(),
        kick: new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: 'exponential' } }).toDestination(),
        snare: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).toDestination(),
        nag: new Tone.AMSynth({ harmonicity: 1.2, oscillator: { type: "sine" }, envelope: { attack: 0.02, decay: 0.3, sustain: 0.1, release: 0.5 }, modulation: { type: "sawtooth" }, modulationEnvelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.01 } }).toDestination(),
        penis: new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 4, envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 } }).toDestination(),
        boobs: new Tone.FMSynth({ harmonicity: 0.5, modulationIndex: 3, envelope: { attack: 0.05, decay: 0.2, sustain: 0, release: 0.1 }, modulation: { type: "sine" }, modulationEnvelope: { attack: 0.05, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(),
        love: new Tone.MetalSynth({ frequency: 400, harmonicity: 8, modulationIndex: 20, envelope: { attack: 0.01, decay: 0.4, release: 0.2 }, resonance: 4000 }).toDestination(),
        babyWah: new Tone.FMSynth({
            harmonicity: 3.1, modulationIndex: 15, detune: 0, oscillator: { type: "sine" },
            envelope: { attack: 0.02, decay: 0.2, sustain: 0.5, release: 0.8 },
            modulation: { type: "square" }, modulationEnvelope: { attack: 0.05, decay: 0.1, sustain: 0.8, release: 0.5 }
        }).toDestination(),
        pop: new Tone.PluckSynth().toDestination(),
        chomp: new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0 } }).toDestination(),
        zap: new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination(),
        bounce: new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 } }).toDestination(),
        explosion: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.8, sustain: 0.01, release: 1.0, attackCurve: 'exponential' } }).toDestination(),
        captainPunch: new Tone.MembraneSynth({ pitchDecay: 0.1, octaves: 2, oscillator: { type: 'square' } }).toDestination(),
        footKick: new Tone.MembraneSynth({ pitchDecay: 0.02, octaves: 4, oscillator: { type: 'triangle' } }).toDestination(),
        wobblePop: new Tone.PluckSynth({ attackNoise: 0.5, dampening: 4000, resonance: 0.9 }).toDestination(),
        fireExplosion: new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0 } }).toDestination(),
        waterSplash: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0 } }).toDestination(),
        windGust: new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0 } }).toDestination(),
        earthRumble: new Tone.MembraneSynth({ pitchDecay: 0.2, octaves: 1, oscillator: { type: 'sine' } }).toDestination(),
        mogleyLaugh: new Tone.MetalSynth({ frequency: 200, harmonicity: 5, modulationIndex: 10, envelope: { attack: 0.1, decay: 0.5, release: 0.2 } }).toDestination(),
        flowerKiss: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.05 } }).toDestination(),
        hypnoZap: new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.2 } }).toDestination(),
        blackHoleSuck: new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.5 } }).toDestination()
    };
    synths.bass.volume.value = -10; synths.snare.volume.value = -6; synths.nag.volume.value = -8;
    synths.penis.volume.value = -12; synths.boobs.volume.value = -8; synths.love.volume.value = -15;
    synths.babyWah.volume.value = -3;
    synths.pop.volume.value = -10; synths.chomp.volume.value = -8; synths.zap.volume.value = -12;
    synths.bounce.volume.value = -15; synths.explosion.volume.value = -5;
    synths.captainPunch.volume.value = -8;
    synths.footKick.volume.value = -10;
    synths.wobblePop.volume.value = -10;
    synths.fireExplosion.volume.value = -8; synths.waterSplash.volume.value = -10;
    synths.windGust.volume.value = -12; synths.earthRumble.volume.value = -8;
    synths.mogleyLaugh.volume.value = -5;
    synths.flowerKiss.volume.value = -15; synths.hypnoZap.volume.value = -10;
    synths.blackHoleSuck.volume.value = -5;

    const patterns = {
        intro:  { lead: [],                            bass: ['C2'], kick: true, snare: false },
        verse:  { lead: ['C4', null, 'E4', 'G4', null, 'E4', 'C4', null], bass: ['C2', 'G1', 'A1', 'F1'], kick: true, snare: true },
        chorus: { lead: ['C5', 'G4', 'A4', 'G4', 'C5', 'A4', 'G4', 'E4'], bass: ['F1', 'C1', 'G1', 'C1'], kick: true, snare: true },
        bridge: { lead: ['D5', 'E5', 'F#5', 'E5'],                    bass: ['D2', 'A1'], kick: false, snare: false },
        outro:  { lead: ['C4'],                            bass: ['C2'], kick: false, snare: false }
    };

    let beat = 0;
    let songPosition = 0;
    const songStructure = ['intro', 'intro', 'verse', 'verse', 'chorus', 'chorus', 'verse', 'bridge', 'chorus', 'chorus', 'outro', 'outro'];

    const musicLoop = new Tone.Loop(time => {
        Tone.Draw.schedule(() => {
            const currentPart = patterns[songStructure[songPosition]];
            
            if (currentPart.lead.length > 0) {
                const note = currentPart.lead[beat % currentPart.lead.length];
                if (note) synths.lead.triggerAttackRelease(note, '16n', time);
            }
            if (currentPart.bass.length > 0 && beat % 4 === 0) {
                const note = currentPart.bass[Math.floor(beat / 4) % currentPart.bass.length];
                if (note) synths.bass.triggerAttackRelease(note, '4n', time);
            }
            if (currentPart.kick && beat % 4 === 0) {
                synths.kick.triggerAttackRelease('C2', '8n', time);
            }
            if (currentPart.snare && beat % 8 === 4) {
                synths.snare.triggerAttackRelease('16n', time);
            }

            beat++;
            if (beat >= 16) {
                beat = 0;
                songPosition = (songPosition + 1) % songStructure.length;
            }
        }, time);
    }, '16n');

    music = { loop: musicLoop, synths };
}


// --- Sizing and Responsiveness ---
function resizeCanvas() {
    canvas.width = gameContainer.clientWidth;
    canvas.height = gameContainer.clientWidth * 0.6;
    if (gameState !== 'playing') drawInitialState();
}

// --- Player Class ---
class Player {
    constructor() {
        this.x = 50; this.y = canvas.height - 60;
        this.width = 40; this.height = 50;
        this.dx = 0; this.dy = 0; this.jumpPower = 18; this.gravity = 0.8;
        this.moveSpeed = 5;
        this.friction = 0.85;

        this.isJumping = false; this.isDucking = false; this.duckHeight = 30;
        this.rotation = 0;
        this.jumpsRemaining = 2; this.maxJumps = 2;
        this.powerupType = 'normal'; this.powerupTimer = 0;
        this.isSlamming = false;
        this.shootCooldown = 0;
        this.hitText = '';
        this.hitTextTimer = 0;
        this.maxHealth = 100;
        this.health = this.maxHealth;
        this.invincibleTimer = 0;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
        ctx.rotate(this.rotation);
        ctx.fillStyle = '#3498db';
        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
        ctx.restore();

        if (this.hitTextTimer > 0) {
            ctx.globalAlpha = this.hitTextTimer / 60;
            ctx.fillStyle = '#e74c3c';
            ctx.font = '20px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(this.hitText, this.x + this.width / 2, this.y - 10);
            ctx.globalAlpha = 1.0;
        }
    }

    update() {
        let currentGravity = this.gravity;
        if (this.isJumping && keys['ArrowUp']) {
            if (this.powerupType === 'hover') currentGravity = 0.1;
            if (this.powerupType === 'jetpack') this.dy -= 1.2;
        }
        
        if (this.shootCooldown > 0) this.shootCooldown--;

        this.x += this.dx;
        this.y += this.dy;
        this.dx *= this.friction;
        this.dy += currentGravity;

        if (this.x < 0) { this.x = 0; this.dx = 0; }
        if (this.x + this.width > canvas.width) { this.x = canvas.width - this.width; this.dx = 0; }
        if (this.y < 0) { this.y = 0; if (this.dy < 0) this.dy = 0; }
        if (this.y + this.height >= canvas.height) {
            this.land();
        }

        if (this.isJumping) this.rotation += 0.2;
        
        if (this.powerupTimer > 0) {
            this.powerupTimer--;
            powerupStatusEl.textContent = `${this.powerupType.replace('_', ' ').toUpperCase()}! ${Math.ceil(this.powerupTimer / 60)}s`;
            if (this.powerupTimer <= 0) this.resetPowerup();
        } else {
            const weaponTypes = ['normal', 'mortar', 'multi', 'spiral', 'goose', 'love', 'random', 'penis', 'boobs', 'grandma', 'crying_baby', 'bear_poop', 'pacman', 'pokemon', 'bouncing', 'snowball', 'captain_planet', 'foot_gun', 'flower', 'hypno_toad'];
            if (weaponTypes.includes(this.powerupType)) {
                 powerupStatusEl.textContent = `${this.powerupType.replace('_', ' ').toUpperCase()}`;
            }
        }
        if (this.hitTextTimer > 0) {
            this.hitTextTimer--;
        }
        if (this.invincibleTimer > 0) {
            this.invincibleTimer--;
        }
        this.draw();
    }

    land() {
        this.y = canvas.height - this.height;
        if (this.isSlamming) { obstacles.forEach(o => o.takeDamage(1000)); this.isSlamming = false; }
        this.isJumping = false;
        this.dy = 0;
        this.jumpsRemaining = this.maxJumps;
        this.rotation = 0;
    }

    jump() {
        if (this.jumpsRemaining > 0) {
            this.isJumping = true;
            this.dy = -this.jumpPower;
            this.jumpsRemaining--;
        }
    }
    
    duck(shouldDuck) { if (!this.isJumping) this.isDucking = shouldDuck; }

    slam() {
        if (this.isJumping && this.powerupType === 'slam') {
            this.dy = 35;
            this.powerupTimer = 0;
            this.resetPowerup();
            this.isSlamming = true;
        }
    }

    equipPowerup(type, category) {
        this.resetPowerup(); this.powerupType = type;
        if (category === 'jump') {
            this.powerupTimer = (type === 'slam') ? 1200 : 600;
            if (type === 'triple_jump') this.maxJumps = 3;
        } else if (category === 'weapon') {
            this.powerupTimer = 900;
        }
        this.jumpsRemaining = this.maxJumps;
    }
    
    resetPowerup() {
        this.powerupType = 'normal'; this.maxJumps = 2;
        this.jumpsRemaining = Math.min(this.jumpsRemaining, 2);
        powerupStatusEl.textContent = '';
    }

    triggerHitAnimation() {
        const hitPhrases = ["OFF FUCK!", "OUCHIE MAMA!", "DANG IT!", "ZAP!", "BOOM!"];
        this.hitText = hitPhrases[Math.floor(Math.random() * hitPhrases.length)];
        this.hitTextTimer = 60;
    }

    takeDamage(amount) {
        if (this.invincibleTimer <= 0) {
            this.health -= amount;
            if (this.health < 0) this.health = 0;
            this.invincibleTimer = 30;
            updateHealthUI();
        }
    }

    heal(amount) {
        this.health += amount;
        if (this.health > this.maxHealth) this.health = this.maxHealth;
        updateHealthUI();
    }
}

// --- Obstacle Types and Class ---
const obstacleTypes = {
    white: { health: 1, color: '#ecf0f1', damage: 10 },
    yellow: { health: 3, color: '#f1c40f', damage: 20 },
    red: { health: 10, color: '#e74c3c', damage: 30 },
    boss: { health: 200, color: '#8B0000', damage: 50, width: 100, height: 100 }
};

class Obstacle {
    constructor(x, y, w, h, strength, isBoss = false) {
        this.x = x; this.y = y; this.width = w; this.height = h;
        this.strength = strength; this.health = obstacleTypes[strength].health; this.color = obstacleTypes[strength].color;
        this.naggingGrandmas = 0;
        this.isMelting = false; 
        this.animOffset = Math.random() * 100;
        this.snowballCount = 0;
        this.isHypnotized = false;
        this.hypnoRotation = 0;
        this.isBoss = isBoss;
        this.damage = obstacleTypes[strength].damage;
    }
    draw() {
        ctx.save();
        const wiggleAmount = 5;
        const wiggleSpeed = 0.05;
        let currentYOffset = Math.sin((frameCount + this.animOffset) * wiggleSpeed) * wiggleAmount;
        ctx.translate(0, currentYOffset);

        if (this.isHypnotized) {
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.rotate(this.hypnoRotation);
            ctx.translate(-(this.x + this.width / 2), -(this.y + this.height / 2));
        }

        if (this.naggingGrandmas >= 3 && frameCount % 10 < 5) {
            ctx.fillStyle = '#ffffff';
        } else {
            ctx.fillStyle = this.color;
        }
        if (this.isMelting) {
             ctx.globalAlpha = this.health / obstacleTypes[this.strength].health;
        }
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        if (this.snowballCount > 0) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '12px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.snowballCount, this.x + this.width / 2, this.y - 10);
        }

        ctx.restore();
    }
    update() {
        if (this.naggingGrandmas >= 3) {
            this.health = 0;
            for(let i=0; i<10; i++) particles.push(new Particle(this.x + this.width/2, this.y + this.height/2, 'boredom'));
        }
        if (this.isMelting) {
            this.health -= 0.1;
            this.y += 0.5;
        }
        if (this.isHypnotized) {
            this.hypnoRotation += 0.3;
            this.x += (canvas.width / 2 - this.x) * 0.05;
            this.y += (canvas.height / 2 - this.y) * 0.05;
            this.width *= 0.98;
            this.height *= 0.98;
            if (this.width < 5 || this.height < 5) {
                this.health = 0;
                particles.push(new Particle(this.x + this.width/2, this.y + this.height/2, 'black_hole'));
                if (music && music.synths.blackHoleSuck) music.synths.blackHoleSuck.triggerAttackRelease('C1', '0.5s', Tone.now());
            }
        } else {
            this.x -= gameSpeed;
        }
        this.draw();
    }
    takeDamage(amount) { this.health -= amount; }
}

class Bullet {
    constructor(x, y, type = 'normal', angle = 0) {
        this.x = x; this.y = y; this.type = type;
        this.dx = 10; this.dy = 0; this.damage = 1; this.gravity = 0.3; this.angle = angle;
        this.target = null; this.stuckTo = null; this.life = 180;
        this.width = 15; this.height = 5;
        this.animFrame = 0;
        this.state = 'flying';
        
        if (type === 'mortar') { this.width = 15; this.height = 15; this.dy = -12; }
        else if (type === 'multi' || type === 'random') { this.width = 8; this.height = 8; this.dx = (Math.random() - 0.5) * 12; this.dy = (Math.random() - 0.5) * 12; }
        else if (type === 'spiral') { this.width = 10; this.height = 10; this.dx = Math.cos(frameCount * 0.1) * 8; this.dy = Math.sin(frameCount * 0.1) * 8; }
        else if (type === 'goose') { this.width = 12; this.height = 6; this.dy = Math.sin(this.angle) * 8; this.dx = Math.cos(this.angle) * 8;}
        else if (type === 'love') { this.width = 10; this.height = 10; }
        else if (type === 'penis') {
            this.width = 8; this.height = 20; this.state = 'charging'; this.dx = 0; this.dy = -8; this.life = 30;
            this.liquidType = Math.random() < 0.5 ? 'white' : 'yellow';
        }
        else if (type === 'boobs') { this.state = 'growing'; this.currentSize = 5; this.maxSize = 40; this.growSpeed = 2; this.width = this.currentSize * 2; this.height = this.currentSize; this.dx = 0; }
        else if (type === 'grandma') {
            this.width = 15; this.height = 15; this.state = 'seeking_orbit'; this.seek();
            this.hasNagged = false;
        }
        else if (type === 'crying_baby') {
            this.width = 20; this.height = 20; this.state = 'seeking'; this.damage = 5; this.seek();
        }
        else if (type === 'bear_poop') {
            this.width = 30; this.height = 30; this.damage = 1;
            this.dx = 8; this.dy = 0;
        }
        else if (type === 'pacman') {
            this.width = 25; this.height = 25; this.damage = 1000;
            this.dx = 10; this.mouthAngle = 0; this.mouthSpeed = 0.2;
            this.state = 'seeking';
        }
        else if (type === 'pokemon') {
            this.width = 20; this.height = 20; this.damage = 5;
            const elements = ['fire', 'water', 'electric'];
            this.element = elements[Math.floor(Math.random() * elements.length)];
            this.dx = 8;
        }
        else if (type === 'bouncing') {
            this.width = 10; this.height = 10; this.damage = 2;
            this.dx = 8 * (Math.random() < 0.5 ? 1 : -1);
            this.dy = 8 * (Math.random() < 0.5 ? 1 : -1);
            this.hitCount = 0;
            this.maxHits = 3;
        }
        else if (type === 'snowball') {
            this.width = 10; this.height = 10; this.damage = 0;
            this.dx = 8;
            this.mergeCount = 1;
            this.maxMergeCount = 20;
        }
        else if (type === 'captain_planet') {
            this.width = 15; this.height = 15; this.damage = 5;
            const elements = ['earth', 'fire', 'wind', 'water', 'heart'];
            this.element = elements[Math.floor(Math.random() * elements.length)];
            this.dx = 10;
        }
        else if (type === 'foot_gun') {
            this.width = 25; this.height = 15; this.damage = 10;
            this.dx = (Math.random() - 0.5) * 8;
            this.dy = (Math.random() - 0.5) * 8;
            this.walkAnimFrame = 0; this.walkAnimSpeed = 0.2;
            this.life = 300;
            this.kickCooldown = 0;
        }
        else if (type === 'flower') {
            this.width = 10; this.height = 10; this.damage = 5;
            this.dx = 8; this.dy = 0; this.gravity = 0.5;
            this.state = 'seed_flying';
            this.growthStage = 0; this.maxGrowthStage = 30;
            this.kissCooldown = 0;
            this.target = null;
            this.currentGrowth = 0; // FIX: New property for growth animation
        }
        else if (type === 'hypno_toad') {
            this.width = 30; this.height = 20; this.damage = 1000;
            this.dx = 5; this.dy = 0;
            this.state = 'seeking';
            this.target = null;
        }
    }
    draw() {
        ctx.fillStyle = '#ffc0cb';
        switch(this.type) {
            case 'love': ctx.font = "15px 'Press Start 2P'"; ctx.fillText("â¤", this.x, this.y); break;
            case 'penis':
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                ctx.beginPath(); ctx.arc(0, -this.height/2, this.width, 0, Math.PI); ctx.fill();
                ctx.restore();
                break;
            case 'boobs':
                ctx.beginPath(); ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(this.x + this.currentSize * 1.5, this.y, this.currentSize, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#d48a96';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.currentSize * 0.2, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(this.x + this.currentSize * 1.5, this.y, this.currentSize * 0.2, 0, Math.PI * 2); ctx.fill();
                break;
            case 'grandma':
                const wobbleX = Math.sin(this.animFrame * 0.5) * 2; const wobbleY = Math.cos(this.animFrame * 0.3) * 2;
                ctx.save(); ctx.translate(this.x + wobbleX, this.y + wobbleY);
                ctx.fillStyle = '#f0d9c4'; ctx.fillRect(0, 0, this.width, this.height);
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.width/2, 0, this.width/2, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#000'; ctx.fillRect(3, 5, 2, 2); ctx.fillRect(10, 5, 2, 2);
                ctx.restore();
                break;
            case 'crying_baby':
                ctx.fillStyle = '#f0d9c4'; ctx.beginPath(); ctx.arc(this.x, this.y, this.width / 2, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#000'; ctx.fillRect(this.x - 5, this.y - 2, 2, 2); ctx.fillRect(this.x + 3, this.y - 2, 2, 2);
                ctx.strokeStyle = '#000'; ctx.beginPath(); ctx.arc(this.x, this.y + 5, 4, 0, Math.PI); ctx.stroke();
                if (frameCount % 5 === 0) { particles.push(new Particle(this.x, this.y + 10, 'tear')); }
                break;
            case 'bear_poop':
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.beginPath();
                ctx.arc(this.x + 5, this.y, 5, 0, Math.PI * 2); ctx.fill();
                ctx.arc(this.x + this.width - 5, this.y, 5, 0, Math.PI * 2); ctx.fill();
                break;
            case 'pacman':
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                this.mouthAngle += this.mouthSpeed;
                if (this.mouthAngle > Math.PI / 4 || this.mouthAngle < 0) {
                    this.mouthSpeed *= -1;
                }
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, this.mouthAngle, Math.PI * 2 - this.mouthAngle);
                ctx.lineTo(this.x + this.width / 2, this.y + this.height / 2);
                ctx.closePath();
                ctx.fill();
                break;
            case 'pokemon':
                let pokemonColor;
                let pokemonText;
                switch(this.element) {
                    case 'fire': pokemonColor = '#FF4500'; pokemonText = 'F'; break;
                    case 'water': pokemonColor = '#1E90FF'; pokemonText = 'W'; break;
                    case 'electric': pokemonColor = '#FFD700'; pokemonText = 'E'; break;
                }
                ctx.fillStyle = pokemonColor;
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = '12px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(pokemonText, this.x + this.width / 2, this.y + this.height / 2 + 2);
                break;
            case 'bouncing':
                ctx.fillStyle = '#00FFFF';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = '10px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.maxHits - this.hitCount, this.x + this.width / 2, this.y + this.height / 2 + 2);
                break;
            case 'snowball':
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + (this.mergeCount / this.maxMergeCount) * 0.5})`;
                const currentSize = this.width + (this.mergeCount / this.maxMergeCount) * 20;
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, currentSize / 2, 0, Math.PI * 2);
                ctx.fill();
                break;
            case 'captain_planet':
                let cpColor;
                switch(this.element) {
                    case 'earth': cpColor = '#228B22'; break;
                    case 'fire': cpColor = '#FF4500'; break;
                    case 'wind': cpColor = '#ADD8E6'; break;
                    case 'water': cpColor = '#4169E1'; break;
                    case 'heart': cpColor = '#FF69B4'; break;
                }
                ctx.fillStyle = cpColor;
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 4, 0, Math.PI * 2);
                ctx.fill();
                break;
            case 'foot_gun':
                ctx.fillStyle = '#A0522D';
                const footOffset = Math.sin(this.walkAnimFrame * this.walkAnimSpeed) * 3;
                // Left foot
                ctx.fillRect(this.x, this.y + footOffset, this.width / 2 - 2, this.height);
                ctx.beginPath(); // Toes
                ctx.arc(this.x + this.width / 4, this.y + this.height + footOffset, this.width / 4, 0, Math.PI, true);
                ctx.fill();
                // Right foot
                ctx.fillRect(this.x + this.width / 2 + 2, this.y - footOffset, this.width / 2 - 2, this.height);
                ctx.beginPath(); // Toes
                ctx.arc(this.x + this.width * 3 / 4 + 2, this.y + this.height - footOffset, this.width / 4, 0, Math.PI, true);
                ctx.fill();
                break;
            case 'flower':
                if (this.state === 'seed_flying') {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                } else {
                    const scale = this.currentGrowth / this.maxGrowthStage; // FIX: Use currentGrowth for scaling
                    const flowerWidth = this.width * scale * 2;
                    const flowerHeight = this.height * scale * 2;
                    const drawX = this.x;
                    const drawY = this.y;

                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(drawX + flowerWidth / 4 - 2.5, drawY, 5, flowerHeight);

                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(drawX + flowerWidth / 4, drawY + flowerHeight * 0.3, flowerWidth / 4, 0, Math.PI * 2); ctx.fill();
                    ctx.arc(drawX - flowerWidth / 4, drawY + flowerHeight * 0.3, flowerWidth / 4, 0, Math.PI * 2); ctx.fill();
                    ctx.arc(drawX, drawY + flowerHeight * 0.3 - flowerWidth / 4, flowerWidth / 4, 0, Math.PI * 2); ctx.fill();
                    ctx.arc(drawX, drawY + flowerHeight * 0.3 + flowerWidth / 4, flowerWidth / 4, 0, Math.PI * 2); ctx.fill();
                    
                    ctx.fillStyle = '#FF8C00';
                    ctx.beginPath();
                    ctx.arc(drawX, drawY + flowerHeight * 0.3, flowerWidth / 6, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
            case 'hypno_toad':
                ctx.fillStyle = '#2E8B57';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.x + this.width * 0.3, this.y + this.height * 0.3, 3, 0, Math.PI * 2); ctx.fill();
                ctx.arc(this.x + this.width * 0.7, this.y + this.height * 0.3, 3, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x + this.width * 0.3 + Math.sin(this.animFrame * 0.1) * 2, this.y + this.height * 0.3, 1.5, 0, Math.PI * 2); ctx.fill();
                ctx.arc(this.x + this.width * 0.7 + Math.sin(this.animFrame * 0.1) * 2, this.y + this.height * 0.3, 1.5, 0, Math.PI * 2); ctx.fill();
                break;
            default:
                ctx.fillStyle = '#9b59b6'; ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    }
    update() {
        this.animFrame++;
        if (this.stuckTo) {
            this.x += this.stuckTo.x - this.stuckTo.prevX; this.y += this.stuckTo.y - this.stuckTo.prevY;
            this.stuckTo.prevX = this.stuckTo.x; this.stuckTo.prevY = this.stuckTo.y;
            this.life--;
            if (this.life <= 0) {
                if (this.type === 'love') {
                    for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, 'love'));
                    this.stuckTo.takeDamage(5);
                } else if (this.type === 'snowball') {
                    if (music && music.synths.explosion) music.synths.explosion.triggerAttackRelease('C4', '1s', Tone.now());
                    for(let i=0; i<80; i++) {
                        particles.push(new Particle(this.x, this.y, 'orgasm', Math.random() * 20 + 10));
                    }
                    this.stuckTo.takeDamage(this.mergeCount * 10);
                }
                this.remove = true;
            }
        } else {
            switch(this.state) {
                case 'growing':
                    this.currentSize += this.growSpeed;
                    if (this.currentSize >= this.maxSize) { this.state = 'flying'; this.dx = 12; }
                    break;
                case 'charging':
                    this.life--; this.y += this.dy; this.dy *= 0.9;
                    if(this.life <= 0) { this.state = 'seeking'; this.seek(); }
                    break;
                case 'seeking':
                case 'seeking_orbit':
                    this.seek(); this.x += this.dx; this.y += this.dy;
                    if (this.type === 'grandma' && this.target) {
                        const dist = Math.hypot(this.x - this.target.x, this.y - this.y);
                        if (dist < 50) {
                            this.state = 'orbiting';
                            this.target.naggingGrandmas++;
                            if (music && music.synths.nag && !this.hasNagged) {
                                music.synths.nag.triggerAttackRelease('G#5', '0.3s', Tone.now());
                                this.hasNagged = true;
                            }
                        }
                    }
                    break;
                case 'orbiting':
                    this.x += (this.target.x - 40 - this.x) * 0.1; this.y += (this.target.y - this.y) * 0.1;
                    if (!this.target || this.target.health <= 0) {
                        this.remove = true;
                        if (this.type === 'grandma' && this.target) {
                            this.target.naggingGrandmas = Math.max(0, this.target.naggingGrandmas - 1);
                        }
                        this.hasNagged = false;
                    }
                    break;
                case 'seed_flying':
                    this.x += this.dx;
                    this.y += this.dy;
                    this.dy += this.gravity;
                    if (this.y + this.height >= canvas.height - 50) {
                        this.y = canvas.height - 50 - this.height;
                        this.dx = 0; this.dy = 0; this.gravity = 0;
                        this.state = 'growing';
                        this.life = this.maxGrowthStage; // Life becomes growth timer (incorrect, should be overall lifespan)
                    }
                    break;
                case 'growing':
                    this.currentGrowth++; // FIX: Increment currentGrowth
                    if (this.currentGrowth >= this.maxGrowthStage) { // FIX: Check currentGrowth against maxGrowthStage
                        this.state = 'kissing';
                        this.life = 600; // Overall lifespan for kissing stage
                    }
                    break;
                case 'kissing':
                    this.life--;
                    if (this.life <= 0) { this.remove = true; }
                    if (this.kissCooldown > 0) { this.kissCooldown--; }
                    else {
                        let closestObstacle = null;
                        let minDistance = Infinity;
                        obstacles.forEach(o => {
                            const dist = Math.hypot(this.x - o.x, this.y - o.y);
                            if (dist < minDistance && !o.isHypnotized) {
                                minDistance = dist;
                                closestObstacle = o;
                            }
                        });
                        if (closestObstacle && minDistance < 100) {
                            closestObstacle.takeDamage(this.damage);
                            particles.push(new Particle(closestObstacle.x + closestObstacle.width/2, closestObstacle.y + closestObstacle.height/2, 'kiss'));
                            if (music && music.synths.flowerKiss) music.synths.flowerKiss.triggerAttackRelease('C5', '16n', Tone.now());
                            this.kissCooldown = 30;
                        }
                    }
                    this.x -= gameSpeed;
                    break;
                case 'hypnotizing':
                    this.life--;
                    if (this.life <= 0 || !this.target || this.target.health <= 0) {
                        this.remove = true;
                        if (this.target && this.target.isHypnotized) {
                            this.target.health = 0;
                        }
                    }
                    this.x = this.target.x + this.target.width / 2 - this.width / 2;
                    this.y = this.target.y + this.target.height / 2 - this.height / 2;
                    break;
                case 'flying':
                default:
                    if (this.type === 'mortar') this.dy += this.gravity;
                    
                    if (this.type === 'bouncing') {
                        // Bouncing logic already handles wall collisions
                    }
                    if (this.type === 'foot_gun') {
                        this.walkAnimFrame++;
                        this.life--;
                        if (this.life <= 0) this.remove = true;

                        if (frameCount % 30 === 0) {
                            this.dx = (Math.random() - 0.5) * 8;
                            this.dy = (Math.random() - 0.5) * 8;
                        }
                        if (this.x + this.width > canvas.width || this.x < 0) {
                            this.dx *= -1;
                        }
                        if (this.y + this.height > canvas.height || this.y < 0) {
                            this.dy *= -1;
                        }
                        if (this.kickCooldown > 0) {
                            this.kickCooldown--;
                        }
                    }

                    this.x += this.dx; this.y += this.dy;
            }
        }
        this.draw();
    }
    seek() {
        if (!this.target || !obstacles.includes(this.target) || this.target.health <= 0 || this.target.isHypnotized) {
            let closest = null; let closestDist = Infinity;
            obstacles.forEach(o => {
                const dist = Math.hypot(this.x - o.x, this.y - o.y);
                if (dist < closestDist && !o.isHypnotized) {
                    closest = o; closestDist = dist;
                }
            });
            this.target = closest;
        }
        if (this.target) {
            let speed = 8;
            if (this.type === 'penis') speed = 15;
            if (this.type === 'crying_baby') speed = 3;
            if (this.type === 'pokemon') speed = 10;
            if (this.type === 'captain_planet') speed = 10;
            if (this.type === 'pacman') speed = 12;
            if (this.type === 'hypno_toad') speed = 6;

            const targetAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
            this.dx = Math.cos(targetAngle) * speed; this.dy = Math.sin(targetAngle) * speed;
            this.angle = targetAngle;
        } else if (this.type === 'penis' || this.type === 'grandma' || this.type === 'crying_baby' || this.type === 'pokemon' || this.type === 'captain_planet' || this.type === 'pacman' || this.type === 'hypno_toad') {
            this.remove = true;
        }
    }
}

class Collectible {
    constructor(x, y, powerupType, category) {
        this.x = x; this.y = y; this.width = 30; this.height = 30;
        this.powerupType = powerupType; this.category = category;
        this.color = (category === 'weapon') ? '#e67e22' : '#2ecc71';
    }
    draw() {
        ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.fillStyle = '#ffffff'; ctx.font = '20px "Press Start 2P"';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        const letter = this.category === 'weapon' ? 'W' : 'J';
        ctx.fillText(letter, this.x + this.width / 2, this.y + this.height / 2 + 2);
    }
    update() { this.x -= gameSpeed; this.draw(); }
}

class Particle {
    constructor(x, y, type, initialSize = 10) {
        this.x = x; this.y = y; this.type = type; this.life = 60;
        this.dx = (Math.random() - 0.5) * 6;
        this.dy = (Math.random() - 0.5) * 6;
        this.gravity = 0.1;
        this.isStuck = false;
        this.color = '#fff';
        if (type === 'fire') { this.color = '#FF4500'; this.dx = (Math.random() - 0.5) * 8; this.dy = -Math.random() * 8; this.life = 30; }
        else if (type === 'water') { this.color = '#1E90FF'; this.dx = (Math.random() - 0.5) * 6; this.dy = Math.random() * 6; this.life = 40; }
        else if (type === 'electric') { this.color = '#FFD700'; this.dx = (Math.random() - 0.5) * 10; this.dy = (Math.random() - 0.5) * 10; this.life = 20; }
        else if (type === 'orgasm') {
            this.initialLife = 60;
            this.dx = (Math.random() - 0.5) * 10;
            this.dy = (Math.random() - 0.5) * 10;
            this.size = initialSize;
            this.growthRate = Math.random() * 0.5 + 0.1;
            this.color = `rgb(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)})`;
        }
        else if (type === 'captain_planet_punch') {
            this.life = 30;
            this.size = 50;
            this.growthRate = 2;
            this.color = '#00FFFF';
            this.dx = 0; this.dy = 0;
        }
        else if (type === 'wobble') {
            this.initialLife = 40;
            this.dx = (Math.random() - 0.5) * 3;
            this.dy = (Math.random() - 0.5) * 3;
            this.size = 15;
            this.color = '#00FFFF';
            this.wobbleOffset = Math.random() * Math.PI * 2;
        }
        else if (type === 'fire_explosion') {
            this.initialLife = 20; this.life = 20;
            this.color = '#FF4500'; this.size = 5;
            this.dx = (Math.random() - 0.5) * 10; this.dy = (Math.random() - 0.5) * 10;
            this.gravity = 0;
        }
        else if (type === 'water_splash') {
            this.initialLife = 30; this.life = 30;
            this.color = '#1E90FF'; this.size = 4;
            this.dx = (Math.random() - 0.5) * 8; this.dy = (Math.random() - 0.5) * 8;
            this.gravity = 0.2;
        }
        else if (type === 'wind_gust') {
            this.initialLife = 25; this.life = 25;
            this.color = '#ADD8E6'; this.size = 3;
            this.dx = (Math.random() - 0.5) * 12; this.dy = (Math.random() - 0.5) * 12;
            this.gravity = 0;
        }
        else if (type === 'earth_shake') {
            this.initialLife = 40; this.life = 40;
            this.color = '#8B4513'; this.size = 6;
            this.dx = (Math.random() - 0.5) * 5; this.dy = Math.random() * 5;
            this.gravity = 0.5;
        }
        else if (this.type === 'mogley_face') {
            this.initialLife = 120;
            this.life = 120;
            this.size = 0;
            this.maxSize = Math.min(canvas.width, canvas.height) * 0.8;
            this.growthRate = this.maxSize / this.initialLife;
            this.dx = 0; this.dy = 0; this.gravity = 0;
            this.color = '#A0522D';
        }
        else if (this.type === 'kiss') {
            this.initialLife = 30; this.life = 30;
            this.dx = (Math.random() - 0.5) * 4; this.dy = -Math.random() * 4;
            this.gravity = 0.1;
            this.color = '#FF69B4';
        }
        else if (this.type === 'black_hole') {
            this.initialLife = 45; this.life = 45;
            this.size = 5; this.maxSize = 50;
            this.growthRate = 1;
            this.color = '#000';
            this.dx = 0; this.dy = 0; this.gravity = 0;
        }
    }
    draw() {
        ctx.globalAlpha = this.life / this.initialLife;
        if (this.type === 'love') {
            ctx.fillStyle = '#ff69b4'; ctx.font = "15px 'Press Start 2P'"; ctx.fillText("â¤", this.x, this.y);
        } else if (this.type === 'tear') {
            ctx.fillStyle = '#aed6f1'; ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI * 2); ctx.fill();
        } else if (this.type === 'shockwave') {
            ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x, this.y, (60 - this.life) / 4, 0, Math.PI * 2); ctx.stroke();
        } else if (this.type === 'milk' || this.type === 'sticky_goo') {
            ctx.fillStyle = this.type === 'milk' ? '#ffffff' : '#f5f5f5'; ctx.fillRect(this.x, this.y, 4, 4);
        } else if (this.type === 'nag') {
            ctx.fillStyle = '#aaaaaa'; ctx.font = "8px 'Press Start 2P'"; ctx.fillText("...", this.x, this.y);
        } else if (this.type === 'boredom') {
            ctx.fillStyle = '#ffffff'; ctx.font = "15px 'Press Start 2P'"; ctx.fillText("POOF!", this.x, this.y);
        }
        else if (this.type === 'poop') {
            ctx.fillStyle = '#5A3D2B';
            ctx.beginPath();
            ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
            ctx.fill();
        } else if (this.type === 'elemental') {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
            ctx.fill();
        } else if (this.type === 'orgasm') {
            ctx.fillStyle = this.color;
            ctx.font = `${this.size}px "Press Start 2P"`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("BOOM!", this.x, this.y);
        }
        else if (this.type === 'captain_planet_punch') {
            ctx.fillStyle = this.color;
            ctx.font = `${this.size}px "Press Start 2P"`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("PUNCH!", this.x, this.y);
        }
        else if (this.type === 'wobble') {
            ctx.fillStyle = this.color;
            const wobbleFactor = Math.sin((this.initialLife - this.life) * 0.5 + this.wobbleOffset) * 5;
            ctx.beginPath();
            ctx.ellipse(this.x, this.y, this.size + wobbleFactor, this.size - wobbleFactor, Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();
        }
        else if (type === 'fire_explosion' || type === 'water_splash' || type === 'wind_gust' || type === 'earth_shake') {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
        else if (this.type === 'mogley_face') {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(this.x - this.size * 0.15, this.y - this.size * 0.1, this.size * 0.05, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.x + this.size * 0.15, this.y + this.size * 0.1, this.size * 0.05, 0, Math.PI * 2); // Adjusted Y for right eye
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = this.size * 0.02;
            ctx.beginPath();
            ctx.arc(this.x, this.y + this.size * 0.1, this.size * 0.15, 0, Math.PI);
            ctx.stroke();
        }
        else if (this.type === 'kiss') {
            ctx.fillStyle = this.color;
            ctx.font = '15px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("MWAH!", this.x, this.y);
        }
        else if (this.type === 'black_hole') {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
    }
    update() {
        this.life--;
        if (this.type === 'sticky_goo') {
            if (this.isStuck) {
                this.dy = 0.5;
            } else {
                this.dy += this.gravity;
                if (this.x <= 0 || this.x >= canvas.width || this.y <= 0) {
                    this.isStuck = true;
                    this.dx = 0;
                }
            }
        } else if (this.type === 'milk' || this.type === 'tear' || this.type === 'poop' || this.type === 'elemental' || this.type === 'kiss') {
            this.dy += this.gravity;
        } else if (this.type === 'orgasm') {
            this.size += this.growthRate;
            this.dy += this.gravity * 0.5;
        }
        else if (this.type === 'captain_planet_punch') {
            this.size += this.growthRate;
        }
        else if (this.type === 'wobble') {
            this.dy += this.gravity * 0.2;
        }
        else if (type === 'fire_explosion' || type === 'water_splash' || type === 'wind_gust' || type === 'earth_shake') {
            this.size += 1;
        }
        else if (this.type === 'mogley_face') {
            this.size += this.growthRate;
            if (this.size > this.maxSize) this.size = this.maxSize;
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
        }
        else if (this.type === 'black_hole') {
            this.size += this.growthRate;
            if (this.size > this.maxSize) this.size = this.maxSize;
        }
        this.x += this.dx; this.y += this.dy;
        this.draw();
    }
}


// --- Game Initialization ---
function init() {
    if (Tone.context.state !== 'running') { Tone.start(); }
    setupMusic();
    Tone.Transport.start('+0.1');

    score = 0; lives = 3; frameCount = 0;
    nextExtraLifeScore = 1000;
    blocksPassed = 0;
    nextBossBlockCount = 1000;
    bossActive = false;

    const difficultySettings = { 
        easy:   { speed: 1.2, freq: 68 },
        medium: { speed: 1.6, freq: 57 },
        hard:   { speed: 2.0, freq: 45 }
    };
    const setting = difficultySettings[difficulty];
    gameSpeed = setting.speed; obstacleFrequency = setting.freq;

    player = new Player();
    obstacles = []; bullets = []; collectibles = []; particles = [];
    
    scoreEl.textContent = `Score: ${score}`; livesEl.textContent = `Lives: ${lives}`;
    powerupStatusEl.textContent = '';
    player.health = player.maxHealth;
    updateHealthUI();
    
    startScreen.style.display = 'none'; gameOverScreen.style.display = 'none';
    gameState = 'playing';
    animationFrameId = requestAnimationFrame(gameLoop);
}

// --- Game Loop ---
function gameLoop() {
    if (gameState !== 'playing' || !player) {
        if (gameState === 'over' && !player) {
            cancelAnimationFrame(animationFrameId);
        }
        return;
    }

    animationFrameId = requestAnimationFrame(gameLoop);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    frameCount++;
    
    if (keys['ArrowLeft']) { player.dx -= player.moveSpeed / 5; }
    if (keys['ArrowRight']) { player.dx += player.moveSpeed / 5; }

    player.update();
    handleShooting();

    if (frameCount % 450 === 0) spawnCollectible();
    collectibles.forEach((c, i) => {
        c.update();
        if (checkCollision(player, c)) { player.equipPowerup(c.powerupType, c.category); collectibles.splice(i, 1); }
        if (c.x + c.width < 0) collectibles.splice(i, 1);
    });

    if (blocksPassed >= nextBossBlockCount && !bossActive) {
        spawnObstacle(true);
    } else if (frameCount % obstacleFrequency === 0 && !bossActive) {
        spawnObstacle();
    }

    obstacles.forEach((o, i) => {
        o.prevX = o.x; o.prevY = o.y;
        o.update();
        let removed = false;

        if (o.health <= 0) {
            obstacles.splice(i, 1);
            score += 20; scoreEl.textContent = `Score: ${score}`;
            if (score >= nextExtraLifeScore) {
                lives++;
                livesEl.textContent = `Lives: ${lives}`;
                nextExtraLifeScore += 1000;
            }
            if (o.isBoss) {
                bossActive = false;
                score += 500;
                scoreEl.textContent = `Score: ${score}`;
            }
            blocksPassed++;
            removed = true;
        } else if (checkCollision(player, o)) {
            player.takeDamage(o.damage);
            if (!o.isBoss) {
                obstacles.splice(i, 1);
                blocksPassed++;
                removed = true;
            }
            livesEl.textContent = `Lives: ${lives}`;
            player.triggerHitAnimation();
            if (lives <= 0) endGame();
        }

        if (!removed && o.x + o.width < 0) {
            obstacles.splice(i, 1);
            score += 5; scoreEl.textContent = `Score: ${score}`;
            blocksPassed++;
            if (o.isBoss) {
                bossActive = false;
            }
        }
    });

    bullets.forEach((b, bIndex) => {
        b.update();
        // FIX: Only remove bouncing bullets when their hit count is exhausted or they go VERY far off-screen
        const isBouncingAndAlive = b.type === 'bouncing' && !b.remove;
        const outOfBounds = b.x > canvas.width + 100 || b.x < -100 || b.y > canvas.height + 100 || b.y < -100; // Increased bounds
        
        if (b.remove || (!isBouncingAndAlive && outOfBounds)) { // If it's explicitly removed OR it's not a bouncing bullet and is far out of bounds
            if (b.type === 'grandma' && b.target) b.target.naggingGrandmas--;
            bullets.splice(bIndex, 1);
        }
        
        obstacles.forEach((o, oIndex) => {
            if (checkCollision(b, o)) {
                if (!bullets.includes(b)) return;

                if (b.type === 'crying_baby') {
                    const now = Tone.context.currentTime;
                    if (now - lastBabyWahTime > babyWahCooldown) {
                        if (music && music.synths.babyWah) music.synths.babyWah.triggerAttackRelease('A5', '0.5s', now);
                        lastBabyWahTime = now;
                    }
                    for (let i = 0; i < 20; i++) particles.push(new Particle(b.x, b.y, 'shockwave'));
                    obstacles.forEach(otherObstacle => {
                        const dist = Math.hypot(b.x - otherObstacle.x, b.y - otherObstacle.y);
                        if (dist < 100) { otherObstacle.takeDamage(b.damage); }
                    });
                    bullets.splice(bIndex, 1);
                }
                else if (b.type === 'boobs') {
                    for (let i = 0; i < 30; i++) particles.push(new Particle(b.x, b.y, 'milk'));
                }
                else if (b.type === 'love' && !b.stuckTo) { b.stuckTo = o; } 
                else if (b.type === 'penis') {
                    if (b.liquidType === 'yellow') { o.isMelting = true; } 
                    else { o.takeDamage(1000); for (let i = 0; i < 20; i++) particles.push(new Particle(b.x, b.y, 'sticky_goo')); }
                    bullets.splice(bIndex, 1);
                }
                else if (b.type === 'bear_poop') {
                    if (music && music.synths.pop) music.synths.pop.triggerAttackRelease('C4', '16n', Tone.now());
                    particles.push(new Particle(b.x, b.y, 'poop'));
                    o.takeDamage(b.damage);
                    bullets.splice(bIndex, 1);
                }
                else if (b.type === 'pacman') {
                    if (music && music.synths.chomp) music.synths.chomp.triggerAttackRelease('16n', Tone.now());
                    o.takeDamage(b.damage);
                }
                else if (b.type === 'pokemon') {
                    if (music && music.synths.zap) music.synths.zap.triggerAttackRelease('E5', '16n', Tone.now());
                    for (let i = 0; i < 15; i++) particles.push(new Particle(b.x, b.y, 'elemental', b.element));
                    o.takeDamage(b.damage);
                    bullets.splice(bIndex, 1);
                }
                else if (b.type === 'snowball') {
                    let existingSnowball = bullets.find(bullet => bullet.type === 'snowball' && bullet.stuckTo === o);
                    if (existingSnowball) {
                        existingSnowball.mergeCount++;
                        if (existingSnowball.mergeCount >= existingSnowball.maxMergeCount) {
                            existingSnowball.life = 1;
                        }
                        bullets.splice(bIndex, 1);
                    } else {
                        b.stuckTo = o;
                    }
                }
                else if (b.type === 'captain_planet') {
                    if (music && music.synths.zap) music.synths.zap.triggerAttackRelease('C6', '32n', Tone.now());
                    o.takeDamage(b.damage);
                    bullets.splice(bIndex, 1);
                    switch(b.element) {
                        case 'fire':
                            if (music && music.synths.fireExplosion) music.synths.fireExplosion.triggerAttackRelease('C3', '0.2s', Tone.now());
                            for(let i=0; i<20; i++) particles.push(new Particle(o.x + o.width/2, o.y + o.height/2, 'fire_explosion'));
                            break;
                        case 'water':
                            if (music && music.synths.waterSplash) music.synths.waterSplash.triggerAttackRelease('C4', '0.2s', Tone.now());
                            for(let i=0; i<20; i++) particles.push(new Particle(o.x + o.width/2, o.y + o.height/2, 'water_splash'));
                            break;
                        case 'wind':
                            if (music && music.synths.windGust) music.synths.windGust.triggerAttackRelease('C5', '0.2s', Tone.now());
                            for(let i=0; i<20; i++) particles.push(new Particle(o.x + o.width/2, o.y + o.height/2, 'wind_gust'));
                            break;
                        case 'earth':
                            if (music && music.synths.earthRumble) music.synths.earthRumble.triggerAttackRelease('C2', '0.2s', Tone.now());
                            for(let i=0; i<20; i++) particles.push(new Particle(o.x + o.width/2, o.y + o.height/2, 'earth_shake'));
                            break;
                        case 'heart':
                            const now = Tone.context.currentTime;
                            if (now - lastMogleyFaceTime > mogleyFaceCooldown) {
                                if (music && music.synths.mogleyLaugh) music.synths.mogleyLaugh.triggerAttackRelease('C4', '1s', now);
                                particles.push(new Particle(canvas.width / 2, canvas.height / 2, 'mogley_face'));
                                lastMogleyFaceTime = now;
                            }
                            break;
                    }
                    if (Math.random() < 0.2) {
                        particles.push(new Particle(canvas.width / 2, canvas.height / 2, 'captain_planet_punch'));
                        if (music && music.synths.captainPunch) music.synths.captainPunch.triggerAttackRelease('C3', '0.2s', Tone.now());
                        obstacles.forEach(obs => {
                            obs.takeDamage(50);
                        });
                    }
                }
                else if (b.type === 'foot_gun') {
                    const now = Tone.context.currentTime;
                    if (b.kickCooldown <= 0) {
                        if (music && music.synths.footKick && (now - lastFootKickSoundTime > footKickSoundCooldown)) {
                            music.synths.footKick.triggerAttackRelease('C2', '16n', now);
                            lastFootKickSoundTime = now; // FIX: Update lastFootKickSoundTime
                        }
                        o.takeDamage(b.damage);
                        b.kickCooldown = 15;
                    }
                }
                else if (b.type === 'bouncing') {
                    o.takeDamage(b.damage);
                    b.hitCount++;
                    if (b.hitCount >= b.maxHits) {
                        for(let i=0; i<10; i++) particles.push(new Particle(b.x, b.y, 'wobble'));
                        if (music && music.synths.wobblePop) music.synths.wobblePop.triggerAttackRelease('G4', '16n', Tone.now());
                        b.remove = true;
                    }
                }
                else if (b.type === 'flower') {
                    if (b.state === 'seed_flying' && b.y + b.height >= o.y && b.y < o.y + o.height) {
                        b.target = o;
                        b.state = 'growing';
                        b.dx = 0; b.dy = 0; b.gravity = 0;
                        b.life = b.maxGrowthStage; // This is the life for the flower, not its growth.
                        // The life of the bullet itself (for removal purposes)
                    }
                }
                else if (b.type === 'hypno_toad') {
                    if (b.state === 'seeking') {
                        o.isHypnotized = true;
                        b.target = o;
                        b.state = 'hypnotizing';
                        if (music && music.synths.hypnoZap) music.synths.hypnoZap.triggerAttackRelease('A4', '0.3s', Tone.now());
                        b.life = 60;
                    }
                }
                else if (b.type !== 'love' && b.type !== 'grandma' && b.type !== 'pacman' && b.type !== 'foot_gun' && b.type !== 'flower' && b.type !== 'hypno_toad' && b.type !== 'bouncing') {
                    bullets.splice(bIndex, 1);
                    o.takeDamage(b.damage);
                }
            }
        });
    });

    particles.forEach((p, i) => { p.update(); if (p.life <= 0) particles.splice(i, 1); });
    
    if(frameCount % 500 === 0 && frameCount > 0) {
        gameSpeed += 0.1;
        if (obstacleFrequency > 25) {
            obstacleFrequency -= 2;
        }
    }
}

// --- Helper Functions ---
function spawnObstacle(isBossSpawn = false) {
    let currentObstacleStrength;
    let currentObstacleWidth, currentObstacleHeight;
    let isCurrentBoss = false;

    if (isBossSpawn) {
        currentObstacleStrength = 'boss';
        currentObstacleWidth = obstacleTypes.boss.width;
        currentObstacleHeight = obstacleTypes.boss.height;
        isCurrentBoss = true;
        bossActive = true;
        nextBossBlockCount += 5000;
    } else {
        const rand = Math.random();
        currentObstacleStrength = rand < 0.6 ? 'white' : rand < 0.9 ? 'yellow' : 'red';
        currentObstacleWidth = Math.random() * 20 + 20;
        currentObstacleHeight = Math.random() * 50 + 30;
    }

    let x = canvas.width;
    let y = Math.random() * (canvas.height - currentObstacleHeight);
    if (!isCurrentBoss && Math.random() < 0.5) {
        y = canvas.height - currentObstacleHeight - 50;
    }

    obstacles.push(new Obstacle(x, y, currentObstacleWidth, currentObstacleHeight, currentObstacleStrength, isCurrentBoss));
}

function spawnCollectible() {
    const category = Math.random() < 0.9 ? 'weapon' : 'jump';
    const weaponTypes = ['mortar', 'multi', 'spiral', 'goose', 'love', 'random', 'penis', 'boobs', 'grandma', 'crying_baby', 'bear_poop', 'pacman', 'pokemon', 'bouncing', 'snowball', 'captain_planet', 'foot_gun', 'flower', 'hypno_toad'];
    const jumpTypes = ['triple_jump', 'hover', 'jetpack', 'slam'];
    const type = (category === 'weapon') ? weaponTypes[Math.floor(Math.random() * weaponTypes.length)] : jumpTypes[Math.floor(Math.random() * jumpTypes.length)];
    const y = Math.random() * (canvas.height - 100) + 50;
    const x = canvas.width;
    collectibles.push(new Collectible(x, y, type, category));
}

function checkCollision(rect1, rect2) {
    const r1 = (rect1 === player) ? { x: player.x, y: player.y, width: player.width, height: player.height } : rect1;
    return (r1.x < rect2.x + rect2.width && r1.x + r1.width > rect2.x && r1.y < rect2.y + rect2.height && r1.y + r1.height > rect2.y);
}

function handleShooting() {
    if (player.powerupType === 'random' && frameCount % 3 === 0) {
        bullets.push(new Bullet(Math.random() * canvas.width, Math.random() * canvas.height, 'random'));
    }
    if (keys['Space']) {
        const bX = player.x + player.width / 2, bY = player.y + player.height / 2;
        if (player.powerupType === 'normal' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'normal'));
            player.shootCooldown = 6;
        }
        if (player.powerupType === 'mortar' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'mortar'));
            player.shootCooldown = 20;
        }
        if (player.powerupType === 'multi' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'multi'));
            player.shootCooldown = 2;
        }
        if (player.powerupType === 'spiral' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'spiral'));
            player.shootCooldown = 2;
        }
        if (player.powerupType === 'goose' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'goose', -0.3)); bullets.push(new Bullet(bX, bY, 'goose', 0.3));
            player.shootCooldown = 10;
        }
        if (player.powerupType === 'love' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'love'));
            player.shootCooldown = 8;
            if (music && music.synths.love) music.synths.love.triggerAttackRelease('C6', '0.5s', Tone.now());
        }
        if (player.powerupType === 'penis' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'penis'));
            player.shootCooldown = 20;
            if (music && music.synths.penis) music.synths.penis.triggerAttackRelease('C3', '8n', Tone.now());
        }
        if (player.powerupType === 'boobs' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'boobs'));
            player.shootCooldown = 30;
            if (music && music.synths.boobs) music.synths.boobs.triggerAttackRelease('G2', '16n', Tone.now());
        }
        if (player.powerupType === 'grandma' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'grandma'));
            player.shootCooldown = 15;
        }
        if (player.powerupType === 'crying_baby' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'crying_baby'));
            player.shootCooldown = 45;
        }
        if (player.powerupType === 'bear_poop' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'bear_poop'));
            player.shootCooldown = 25;
        }
        if (player.powerupType === 'pacman' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'pacman'));
            player.shootCooldown = 15;
        }
        if (player.powerupType === 'pokemon' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'pokemon'));
            player.shootCooldown = 30;
        }
        if (player.powerupType === 'bouncing' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'bouncing'));
            player.shootCooldown = 10;
        }
        if (player.powerupType === 'snowball' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'snowball'));
            player.shootCooldown = 12;
        }
        if (player.powerupType === 'captain_planet' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'captain_planet'));
            player.shootCooldown = 20;
        }
        if (player.powerupType === 'foot_gun' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'foot_gun'));
            player.shootCooldown = 10;
        }
        if (player.powerupType === 'flower' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'flower'));
            player.shootCooldown = 20;
        }
        if (player.powerupType === 'hypno_toad' && player.shootCooldown === 0) {
            bullets.push(new Bullet(bX, bY, 'hypno_toad'));
            player.shootCooldown = 40;
        }
    }
}

function endGame() {
    gameState = 'over';
    cancelAnimationFrame(animationFrameId);
    Tone.Transport.stop();
    if (music && music.loop) {
        music.loop.dispose();
        Object.values(music.synths).forEach(synth => synth.dispose());
        music = null;
    }
    gameOverScreen.style.display = 'flex';
    finalScoreEl.textContent = `Final Score: ${score}`;
    player = null;
}

function updateHealthUI() {
    if (player) {
        // These are now global, no need to getElementById every time
        const healthPercentage = (player.health / player.maxHealth) * 100;
        healthBar.style.width = `${healthPercentage}%`;
        healthText.textContent = `${player.health}/${player.maxHealth}`;
    }
}

// --- Event Listeners ---
window.addEventListener('keydown', (e) => {
    if (e.repeat) return; keys[e.code] = true;
    if (gameState !== 'playing') return;
    if (e.code === 'ArrowUp') player.jump();
    if (e.code === 'ArrowDown') { if (player.isJumping) player.slam(); else player.duck(true); }
});
window.addEventListener('keyup', (e) => { keys[e.code] = false; if (e.code === 'ArrowDown') player.duck(false); });

// Touch Controls
let touchStartY = 0;
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); touchStartY = e.touches[0].clientY;
    keys['Space'] = true; keys['ArrowUp'] = true; 
}, { passive: false });
canvas.addEventListener('touchmove', (e) => {
    e.preventDefault(); let touchEndY = e.touches[0].clientY;
    if (touchStartY - touchEndY > 40) { player.jump(); touchStartY = touchEndY; } 
    else if (touchEndY - touchStartY > 40) { if (player.isJumping) player.slam(); else player.duck(true); }
}, { passive: false });
canvas.addEventListener('touchend', (e) => {
    e.preventDefault(); keys['Space'] = false; keys['ArrowUp'] = false; player.duck(false);
}, { passive: false });

// UI Buttons
startBtn.addEventListener('click', () => { if (difficulty) init(); });
restartBtn.addEventListener('click', () => {
    init();
});
difficultySelector.addEventListener('click', (e) => {
    if (e.target.classList.contains('difficulty-btn')) {
        document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('selected'));
        e.target.classList.add('selected');
        difficulty = e.target.dataset.difficulty;
    }
});

// Initial Setup
window.addEventListener('resize', resizeCanvas);
function drawInitialState() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const tempPlayer = new Player();
    tempPlayer.y = canvas.height - 60; tempPlayer.draw();
    ctx.fillStyle = '#4a4b5c';
    ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
}

document.querySelector('[data-difficulty="medium"]').classList.add('selected');
difficulty = 'medium';
resizeCanvas();

</script>
</body>
</html>
